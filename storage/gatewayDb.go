////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2020 Privategrity Corporation                                   /
//                                                                             /
// All rights reserved.                                                        /
////////////////////////////////////////////////////////////////////////////////

// Handles the database ORM for gateways

package storage

import (
	"github.com/jinzhu/gorm"
	"gitlab.com/xx_network/primitives/id"
	"time"
)

// Returns a Client from database with the given id
// Or an error if a matching Client does not exist
func (d *DatabaseImpl) GetClient(id *id.ID) (*Client, error) {
	result := &Client{}
	err := d.db.Take(&result, "id = ?", id.Marshal()).Error
	return result, err
}

// Inserts the given Client into database
// Returns an error if a Client with a matching Id already exists
func (d *DatabaseImpl) InsertClient(client *Client) error {
	return d.db.Create(client).Error
}

// Returns a Round from database with the given id
// Or an error if a matching Round does not exist
func (d *DatabaseImpl) GetRound(id id.Round) (*Round, error) {
	result := &Round{}
	err := d.db.Take(&result, "id = ?", uint64(id)).Error
	return result, err
}

// Returns multiple Rounds from database with the given ids
// Or an error if no matching Rounds exist
func (d *DatabaseImpl) GetRounds(ids []id.Round) ([]*Round, error) {
	// Convert IDs to plain numbers
	plainIds := make([]uint64, len(ids))
	for i, v := range ids {
		plainIds[i] = uint64(v)
	}

	// Execute the query
	results := make([]*Round, 0)
	err := d.db.Where("id IN (?)", plainIds).Find(&results).Error

	return results, err
}

// Inserts the given Round into database if it does not exist
// Or updates the given Round if the provided Round UpdateId is greater
func (d *DatabaseImpl) UpsertRound(round *Round) error {
	// Make a copy of the provided round
	newRound := *round

	// Build a transaction to prevent race conditions
	return d.db.Transaction(func(tx *gorm.DB) error {

		// Attempt to insert the round into the database,
		// or if it already exists, replace round with the database value
		err := tx.FirstOrCreate(round, &Round{Id: round.Id}).Error
		if err != nil {
			return err
		}

		// If the provided round has a greater UpdateId than the database value,
		// overwrite the database value with the provided round
		if round.UpdateId < newRound.UpdateId {
			return tx.Save(&newRound).Error
		}

		// Commit
		return nil
	})
}

// Count the number of MixedMessage in the database for the given roundId
func (d *DatabaseImpl) countMixedMessagesByRound(roundId id.Round) (uint64, error) {
	var count uint64
	err := d.db.Model(&MixedMessage{}).Where("round_id = ?", uint64(roundId)).Count(&count).Error
	return count, err
}

// Returns a slice of MixedMessages from database
// with matching recipientId and roundId
// Or an error if a matching Round does not exist
func (d *DatabaseImpl) getMixedMessages(recipientId *id.ID, roundId id.Round) ([]*MixedMessage, error) {
	results := make([]*MixedMessage, 0)
	err := d.db.Find(&results,
		&MixedMessage{RecipientId: recipientId.Marshal(),
			RoundId: uint64(roundId)}).Error
	return results, err
}

// Inserts the given list of MixedMessage into database
// NOTE: Do not specify Id attribute, it is autogenerated
func (d *DatabaseImpl) InsertMixedMessages(msgs []*MixedMessage) error {
	for _, msg := range msgs {
		err := d.db.Create(msg).Error
		if err != nil {
			return err
		}
	}
	return nil
}

// Deletes all MixedMessages with the given roundId from database
func (d *DatabaseImpl) DeleteMixedMessageByRound(roundId id.Round) error {
	return d.db.Where("round_id = ?", uint64(roundId)).Delete(MixedMessage{}).Error
}

// Returns a BloomFilter from database with the given clientId
// Or an error if a matching BloomFilter does not exist
func (d *DatabaseImpl) getBloomFilters(clientId *id.ID) ([]*BloomFilter, error) {
	results := make([]*BloomFilter, 0)
	err := d.db.Find(&results,
		&BloomFilter{ClientId: clientId.Marshal()}).Error
	return results, err
}

// Inserts the given BloomFilter into database
// NOTE: Do not specify Id attribute, it is autogenerated
func (d *DatabaseImpl) InsertBloomFilter(filter *BloomFilter) error {
	return d.db.Create(filter).Error
}

// Deletes all BloomFilter with the given epochId from database
// Returns an error if a matching BloomFilter does not exist
func (d *DatabaseImpl) deleteBloomFilterByEpoch(epochId uint64) error {
	return d.db.Delete(BloomFilter{}, "epoch_id = ?", epochId).Error

}

// Returns a EphemeralBloomFilter from database with the given recipientId
// Or an error if a matching EphemeralBloomFilter does not exist
func (d *DatabaseImpl) getEphemeralBloomFilters(recipientId *id.ID) ([]*EphemeralBloomFilter, error) {
	results := make([]*EphemeralBloomFilter, 0)
	err := d.db.Find(&results,
		&EphemeralBloomFilter{RecipientId: recipientId.Marshal()}).Error
	return results, err
}

// Inserts the given EphemeralBloomFilter into database
// NOTE: Do not specify Id attribute, it is autogenerated
func (d *DatabaseImpl) InsertEphemeralBloomFilter(filter *EphemeralBloomFilter) error {
	return d.db.Create(filter).Error
}

// Deletes all EphemeralBloomFilter with the given epochId from database
// Returns an error if a matching EphemeralBloomFilter does not exist
func (d *DatabaseImpl) deleteEphemeralBloomFilterByEpoch(epochId uint64) error {
	return d.db.Delete(EphemeralBloomFilter{}, "epoch_id = ?", epochId).Error
}

// Returns an Epoch from the database with the given id
// Or an error if a matching Epoch does not exist
func (d *DatabaseImpl) GetEpoch(id uint64) (*Epoch, error) {
	result := &Epoch{}
	err := d.db.Take(&result, "id = ?", id).Error
	return result, err
}

// Returns the newest Epoch in the database
func (d *DatabaseImpl) GetLatestEpoch() (*Epoch, error) {
	result := &Epoch{}
	err := d.db.Last(&result).Error
	return result, err
}

// Inserts an Epoch with the given roundId into the database
// Returns the newly-created Epoch from the database
func (d *DatabaseImpl) InsertEpoch(roundId id.Round) (*Epoch, error) {
	epoch := &Epoch{
		RoundId:     uint64(roundId),
		DateCreated: time.Now(),
	}
	err := d.db.Create(epoch).Error
	return epoch, err
}
