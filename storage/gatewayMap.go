///////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2020 xx network SEZC                                          //
//                                                                           //
// Use of this source code is governed by a license that can be found in the //
// LICENSE file                                                              //
///////////////////////////////////////////////////////////////////////////////

// Handles the Map backend for gateway storage

package storage

import (
	"bytes"
	"encoding/binary"
	"github.com/pkg/errors"
	jww "github.com/spf13/jwalterweatherman"
	"gitlab.com/elixxir/crypto/hash"
	"gitlab.com/xx_network/primitives/id"
)

// Returns a Client from Storage with the given id
// Or an error if a matching Client does not exist
func (m *MapImpl) GetClient(id *id.ID) (*Client, error) {
	m.RLock()
	client := m.clients[*id]
	m.RUnlock()

	// Return an error if the Client was not found in the map
	if client == nil {
		return nil, errors.Errorf("Could not find Client with ID %v in map.",
			id)
	}

	return client, nil
}

// Inserts the given Client into Storage
// Returns an error if a Client with a matching Id already exists
func (m *MapImpl) InsertClient(client *Client) error {
	// Convert Client's ID to an ID object
	clientID, err := id.Unmarshal(client.Id)
	if err != nil {
		return err
	}

	m.Lock()
	defer m.Unlock()

	// Return an error if a Client with the ID already exists in the map
	if m.clients[*clientID] != nil {
		return errors.Errorf("Could not insert Client. Client with ID %v "+
			"already exists in map.", clientID)
	}

	m.clients[*clientID] = client

	return nil
}

// Returns a Round from Storage with the given id
// Or an error if a matching Round does not exist
func (m *MapImpl) GetRound(id id.Round) (*Round, error) {
	m.RLock()
	round := m.rounds[id]
	m.RUnlock()

	// Return an error if the Round was not found in the map
	if round == nil {
		return nil, errors.Errorf("Could not find Round with ID %v in map.", id)
	}

	return round, nil
}

// Returns multiple Rounds from Storage with the given ids
// Or an error if no matching Rounds exist
func (m *MapImpl) GetRounds(ids []id.Round) ([]*Round, error) {
	m.RLock()
	defer m.RUnlock()

	results := make([]*Round, 0)
	for _, roundId := range ids {
		if round := m.rounds[roundId]; round != nil {
			results = append(results, round)
		}
	}

	if len(results) == 0 {
		return nil, errors.Errorf("Could not find matching Rounds in map.")
	}
	return results, nil
}

// Inserts the given Round into Storage if it does not exist
// Or updates the given Round if the provided Round UpdateId is greater
func (m *MapImpl) UpsertRound(round *Round) error {
	roundID := id.Round(round.Id)

	m.Lock()
	defer m.Unlock()
	// Insert the round if it does not exist or if it does exist, update it if
	// the update ID provided is greater
	if m.rounds[roundID] == nil || round.UpdateId > m.rounds[roundID].UpdateId {
		m.rounds[roundID] = round
	}

	return nil
}

func hashMixedMessageID(recipientId *id.ID, roundId id.Round) mixedMessageIDHash {
	h, err := hash.NewCMixHash()
	if err != nil {
		jww.FATAL.Panicf("Cannot get cmix hash: %s", err)
	}

	h.Write(recipientId.Marshal())

	ridBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(ridBytes, uint64(roundId))

	h.Write(ridBytes)

	hBytes := h.Sum(nil)

	mmidh := mixedMessageIDHash{}
	copy(mmidh[:], hBytes)
	return mmidh
}

// Returns a slice of MixedMessages from Storage
// with matching recipientId and roundId
// Or an error if a matching Round does not exist
func (m *MapImpl) GetMixedMessages(recipientId *id.ID, roundId id.Round) ([]*MixedMessage, bool) {
	var mixedMessages []*MixedMessage
	var hasRound bool
	mmid := hashMixedMessageID(recipientId, roundId)

	m.RLock()
	// Search map for all MixedMessages with matching recipient ID and round ID
	mixedMessages, hasRound = m.mixedMessages[mmid]
	m.RUnlock()

	return mixedMessages, hasRound
}

// Inserts the given MixedMessage into Storage
// NOTE: Do not specify Id attribute, it is autogenerated
func (m *MapImpl) InsertMixedMessage(msg *MixedMessage) error {

	recipeintID, err := id.Unmarshal(msg.RecipientId)
	if err != nil {
		return errors.WithMessage(err, "Failed to unmarshal "+
			"recipient for message")
	}

	roundID := id.Round(msg.RoundId)

	mmid := hashMixedMessageID(recipeintID, roundID)

	var mixedMessages []*MixedMessage

	m.Lock()
	var ok bool
	mixedMessages, ok = m.mixedMessages[mmid]
	if !ok {
		mixedMessages = make([]*MixedMessage, 0)
	}

	m.mixedMessages[mmid] = append(mixedMessages, msg)

	m.Unlock()
	return nil
}

// Deletes all MixedMessages with the given roundId from Storage
func (m *MapImpl) DeleteMixedMessageByRound(roundId id.Round) error {
	m.Lock()
	defer m.Unlock()

	for k, v := range m.mixedMessages {
		if v[0].RoundId == uint64(roundId) {
			delete(m.mixedMessages, k)
		}
	}

	return nil
}

// Returns a BloomFilter from Storage with the given clientId
// Or an error if a matching BloomFilter does not exist
func (m *MapImpl) GetBloomFilters(clientId *id.ID) ([]*BloomFilter, error) {
	var bloomFilters []*BloomFilter

	m.RLock()
	// Search map for all BloomFilters with matching client ID
	for _, bf := range m.bloomFilters {
		if bytes.Equal(bf.ClientId, clientId.Marshal()) {
			bloomFilters = append(bloomFilters, bf)
		}
	}
	m.RUnlock()

	// Return an error if no BloomFilters were found.
	if len(bloomFilters) == 0 {
		return nil, errors.Errorf("Could not find any BloomFilters with the "+
			"client ID %v in map.", clientId)
	}

	return bloomFilters, nil
}

// Inserts the given BloomFilter into Storage
// NOTE: Do not specify Id attribute, it is autogenerated
func (m *MapImpl) InsertBloomFilter(filter *BloomFilter) error {
	m.Lock()
	defer m.Unlock()

	// Return an error if a BloomFilter with the ID already exists in the map
	if m.bloomFilters[m.bloomFiltersCount] != nil {
		return errors.Errorf("Could not insert BloomFilter. BloomFilter with "+
			"ID %v already exists in map.", m.bloomFiltersCount)
	}

	m.bloomFilters[m.bloomFiltersCount] = filter

	m.bloomFiltersCount++

	return nil
}

// Deletes a BloomFilter with the given id from Storage
// Returns an error if a matching BloomFilter does not exist
func (m *MapImpl) DeleteBloomFilter(id uint64) error {
	m.Lock()
	defer m.Unlock()

	// Return an error if a BloomFilter with the ID does not exists in the map
	if m.bloomFilters[id] == nil {
		return errors.Errorf("Could not delete BloomFilter. BloomFilter with "+
			"ID %v does not exists in map.", id)
	}

	delete(m.bloomFilters, id)

	return nil
}

// Returns a EphemeralBloomFilter from Storage with the given recipientId
// Or an error if a matching EphemeralBloomFilter does not exist
func (m *MapImpl) GetEphemeralBloomFilters(recipientId *id.ID) ([]*EphemeralBloomFilter, error) {
	var ephemeralBloomFilter []*EphemeralBloomFilter

	m.RLock()
	// Search map for all EphemeralBloomFilters with matching recipient ID
	for _, ebf := range m.ephemeralBloomFilters {
		if bytes.Equal(ebf.RecipientId, recipientId.Marshal()) {
			ephemeralBloomFilter = append(ephemeralBloomFilter, ebf)
		}
	}
	m.RUnlock()

	// Return an error if no EphemeralBloomFilters were found.
	if len(ephemeralBloomFilter) == 0 {
		return nil, errors.Errorf("Could not find any EphemeralBloomFilters "+
			"with the recipient ID %v in map.", recipientId)
	}

	return ephemeralBloomFilter, nil
}

// Inserts the given EphemeralBloomFilter into Storage
// NOTE: Do not specify Id attribute, it is autogenerated
func (m *MapImpl) InsertEphemeralBloomFilter(filter *EphemeralBloomFilter) error {
	m.Lock()
	defer m.Unlock()

	// Return an error if a BloomFilter with the ID already exists in the map
	if m.ephemeralBloomFilters[m.ephemeralBloomFiltersCount] != nil {
		return errors.Errorf("Could not insert EphemeralBloomFilter."+
			"EphemeralBloomFilter with ID %v already exists in map.",
			m.ephemeralBloomFiltersCount)
	}

	m.ephemeralBloomFilters[m.ephemeralBloomFiltersCount] = filter

	m.ephemeralBloomFiltersCount++

	return nil
}

// Deletes a EphemeralBloomFilter with the given id from Storage
// Returns an error if a matching EphemeralBloomFilter does not exist
func (m *MapImpl) DeleteEphemeralBloomFilter(id uint64) error {
	m.Lock()
	defer m.Unlock()

	// Return an error if a BloomFilter with the ID does not exists in the map
	if m.ephemeralBloomFilters[id] == nil {
		return errors.Errorf("Could not delete EphemeralBloomFilter. "+
			"EphemeralBloomFilter with ID %v does not exists in map.", id)
	}

	delete(m.ephemeralBloomFilters, id)

	return nil
}
